package data.structures.advanced.data.structures;

import utilities.LRUNode;

import java.util.HashMap;
import java.util.Map;

public class ADSExamples {

  /**
   * 1.
   * Problem: Tournament Tree (Winner Tree) and Binary Heap.
   * Solution:
   */

  /**
   * 2.
   * Problem: XOR Linked List &#8211; A Memory Efficient Doubly Linked List  | Set 1.
   * Solution:
   */

  /**
   * 3.
   * Problem: Spaghetti Stack.
   * Solution:
   */

  /**
   * 4.
   * Problem: Decision Trees &#8211; Fake (Counterfeit) Coin Puzzle (12 Coin Puzzle).
   * Solution:
   */

  /**
   * 5.
   * Problem: Trie | (Insert and Search).
   * Solution:
   */

  /**
   * 6.
   * Problem: Trie | (Delete).
   * Solution:
   */

  /**
   * 7.
   * Problem: AVL Tree | Set 1 (Insertion).
   * Solution:
   */

  /**
   * 8.
   * Problem: AVL Tree | Set 2 (Deletion).
   * Solution:
   */

  /**
   * 9.
   * Problem: XOR Linked List â€“ A Memory Efficient Doubly Linked List | Set 2.
   * Solution:
   */

  /**
   * 10.
   * Problem: Find the k most frequent words from a file.
   * Solution:
   */

  /**
   * 11.
   * Problem: Sort numbers stored on different machines.
   * Solution:
   */

  /**
   * 12.
   * Problem: Implement LRU Cache.
   * Solutions: Maintain two data structures. A linked list and a hash table.
   * The hash table should contain the (key, pointer), where pointer is a pointer to the element in the
   * linked list.
   * LRU evicts the least recently used element from the cache.
   * On removing an element, remove from both the linked list and the hash table.
   * On requesting an element, move it to head of the linked list.
   * This solution is O(1) time complexity. Space complexity is O(n)
   */
  class LRUCache {
    int capacity;
    Map<Integer, LRUNode> map = new HashMap<>();
    LRUNode front = null, end = null;

    public LRUCache(int cap) {
      this.capacity = cap;
    }

    public int get(int key) {
      if (map.containsKey(key)) {
        LRUNode node = map.get(key);
        remove(node);
        setHead(node);
        return node.value;
      } else return -1;
    }

    public void remove(LRUNode node) {
      if (node.prev != null) node.prev.next = node.next;
      else front = node.next;
      if (node.next != null) node.next.prev = node.prev;
      else end = node.prev;
    }

    public void setHead(LRUNode node) {
      node.next = front;
      node.prev = null;
      if (front != null) front.prev = node;
      front = node;
      if (end == null)  end = front;
    }

    public void set(int key, int value) {
      if (map.containsKey(key)) {
        LRUNode old = map.get(key);
        old.value = value;
        remove(old);
        setHead(old);
      }else {
        LRUNode newNode = new LRUNode(key, value);
        if (map.size() >= capacity) {
          map.remove(end.key);
          remove(end);
          setHead(newNode);
        }else setHead(newNode);
        map.put(key, newNode);
      }
    }
  }


   class petrolPump
  {
    int petrol;
    int distance;

    // constructor
    public petrolPump(int petrol, int distance)
    {
      this.petrol = petrol;
      this.distance = distance;
    }
  }


  int printTour(petrolPump arr[], int n)
  {
    int start = 0;
    int end = 1;
    int curr_petrol = arr[start].petrol - arr[start].distance;

    // If current amount of petrol in truck becomes less than 0, then
    // remove the starting petrol pump from tour
    while(end != start || curr_petrol < 0)
    {

      // If current amount of petrol in truck becomes less than 0, then
      // remove the starting petrol pump from tour
      while(curr_petrol < 0 && start != end)
      {
        // Remove starting petrol pump. Change start
        curr_petrol -= arr[start].petrol - arr[start].distance;
        start = (start + 1) % n;

        // If 0 is being considered as start again, then there is no
        // possible solution
        if(start == 0)
          return -1;
      }
      // Add a petrol pump to current tour
      curr_petrol += arr[end].petrol - arr[end].distance;

      end = (end + 1)%n;
    }

    // Return starting point
    return start;
  }

  /**
   * 13.
   * Problem: Print unique rows in a given boolean matrix.
   * Solution:
   */

  /**
   * 14.
   * Problem: Given a sequence of words, print all anagrams together | Set 2.
   * Solution:
   */

  /**
   * 15.
   * Problem: Pattern Searching | Set 8 (Suffix Tree Introduction).
   * Solution:
   */

  /**
   * 16.
   * Problem: Ternary Search Tree.
   * Solution:
   */

  /**
   * 17.
   * Problem: Segment Tree | Set 1 (Sum of given range).
   * Solution:
   */

  /**
   * 18.
   * Problem: Segment Tree | Set 2 (Range Minimum Query).
   * Solution:
   */

  /**
   * 19.
   * Problem: Design an efficient data structure for given operations.
   * Solution:
   */

  /**
   * 20.
   * Problem: Skip List | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 21.
   * Problem: Largest Rectangular Area in a Histogram | Set 1.
   * Solution:
   */

  /**
   * 22.
   * Problem: B-Tree | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 23.
   * Problem: B-Tree | Set 2 (Insert).
   * Solution:
   */

  /**
   * 24.
   * Problem: Longest prefix matching &#8211; A Trie based solution in Java.
   * Solution:
   */

  /**
   * 25.
   * Problem: Find all possible interpretations of an array of digits.
   * Solution:
   */

  /**
   * 26.
   * Problem: B-Tree | Set 3 (Delete).
   * Solution:
   */

  /**
   * 27.
   * Problem: Self Organizing List | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 28.
   * Problem: Splay Tree | Set 1 (Search).
   * Solution:
   */

  /**
   * 29.
   * Problem: Splay Tree | Set 2 (Insert).
   * Solution:
   */

  /**
   * 30.
   * Problem: Suffix Array | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 31.
   * Problem: Red-Black Tree | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 32.
   * Problem: Red-Black Tree | Set 2 (Insert).
   * Solution:
   */

  /**
   * 33.
   * Problem: Interval Tree.
   * Solution:
   */

  /**
   * 34.
   * Problem: Red-Black Tree | Set 3 (Delete).
   * Solution:
   */

  /**
   * 35.
   * Problem: Suffix Array | Set 2 (nLogn Algorithm).
   * Solution:
   */

  /**
   * 36.
   * Problem: Data Structure for Dictionary and Spell Checker?.
   * Solution:
   */

  /**
   * 37.
   * Problem: Pattern Searching using a Trie of all Suffixes.
   * Solution:
   */

  /**
   * 38.
   * Problem: Ukkonen&#8217;s Suffix Tree Construction &#8211; Part 1.
   * Solution:
   */

  /**
   * 39.
   * Problem: Ukkonen&#8217;s Suffix Tree Construction &#8211; Part 2.
   * Solution:
   */

  /**
   * 40.
   * Problem: Ukkonen&#8217;s Suffix Tree Construction &#8211; Part 3.
   * Solution:
   */

  /**
   * 41.
   * Problem: K Dimensional Tree | Set 1 (Search and Insert).
   * Solution:
   */

  /**
   * 42.
   * Problem: Ukkonen&#8217;s Suffix Tree Construction &#8211; Part 4.
   * Solution:
   */

  /**
   * 43.
   * Problem: Binomial Heap.
   * Solution:
   */

  /**
   * 44.
   * Problem: Ukkonen&#8217;s Suffix Tree Construction &#8211; Part 5.
   * Solution:
   */

  /**
   * 45.
   * Problem: Ukkonen&#8217;s Suffix Tree Construction &#8211; Part 6.
   * Solution:
   */

  /**
   * 46.
   * Problem: Suffix Tree Application 1 &#8211; Substring Check.
   * Solution:
   */

  /**
   * 47.
   * Problem: Suffix Tree Application 2 &#8211; Searching All Patterns.
   * Solution:
   */

  /**
   * 48.
   * Problem: Suffix Tree Application 3 &#8211; Longest Repeated Substring.
   * Solution:
   */

  /**
   * 49.
   * Problem: Suffix Tree Application 4 &#8211; Build Linear Time Suffix Array.
   * Solution:
   */

  /**
   * 50.
   * Problem: Generalized Suffix Tree 1.
   * Solution:
   */

  /**
   * 51.
   * Problem: Suffix Tree Application 5 &#8211; Longest Common Substring.
   * Solution:
   */

  /**
   * 52.
   * Problem: How to Implement Reverse DNS Look Up Cache?.
   * Solution:
   */

  /**
   * 53.
   * Problem: Binary Indexed Tree or Fenwick Tree.
   * Solution:
   */

  /**
   * 54.
   * Problem: How to Implement Forward DNS Look Up Cache?.
   * Solution:
   */

  /**
   * 55.
   * Problem: Suffix Tree Application 6 &#8211; Longest Palindromic Substring.
   * Solution:
   */

  /**
   * 56.
   * Problem: Generic Linked List in C.
   * Solution:
   */

  /**
   * 57.
   * Problem: Design a data structure that supports insert, delete, search and getRandom in constant time.
   * Solution:
   */

  /**
   * 58.
   * Problem: How to design a tiny URL or URL shortener?.
   * Solution:
   */

  /**
   * 59.
   * Problem: Lazy Propagation in Segment Tree.
   * Solution:
   */

  /**
   * 60.
   * Problem: K Dimensional Tree | Set 2 (Find Minimum).
   * Solution:
   */

  /**
   * 61.
   * Problem: K Dimensional Tree | Set 3 (Delete).
   * Solution:
   */

  /**
   * 62.
   * Problem: Fibonacci Heap | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 63.
   * Problem: Find shortest unique prefix for every word in a given list | Set 1 (Using Trie).
   * Solution:
   */

  /**
   * 64.
   * Problem: Treap (A Randomized Binary Search Tree).
   * Solution:
   */

  /**
   * 65.
   * Problem: Treap | Set 2 (Implementation of Search, Insert and Delete).
   * Solution:
   */

  /**
   * 66.
   * Problem: Find the maximum subarray XOR in a given array.
   * Solution:
   */

  /**
   * 67.
   * Problem: Range Minimum Query (Square Root Decomposition and Sparse Table).
   * Solution:
   */

  /**
   * 68.
   * Problem: Find LCA in Binary Tree using RMQ.
   * Solution:
   */

  /**
   * 69.
   * Problem: Count inversions in an array | Set 3 (Using BIT).
   * Solution:
   */

  /**
   * 70.
   * Problem: Count Inversions of size three in a give array.
   * Solution:
   */

  /**
   * 71.
   * Problem: Heavy Light Decomposition | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 72.
   * Problem: Heavy Light Decomposition | Set 2 (Implementation).
   * Solution:
   */

  /**
   * 73.
   * Problem: Overview of Data Structures | Set 3 (Graph, Trie, Segment Tree and Suffix Tree).
   * Solution:
   */

  /**
   * 74.
   * Problem: Â­Â­kasaiâ€™s Algorithm for Construction of LCP array from Suffix Array.
   * Solution:
   */

  /**
   * 75.
   * Problem: Gomory-Hu Tree | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 76.
   * Problem: Centroid Decomposition of Tree.
   * Solution:
   */

  /**
   * 77.
   * Problem: Persistent data structures.
   * Solution:
   */

  /**
   * 78.
   * Problem: Sparse Set.
   * Solution:
   */

  /**
   * 79.
   * Problem: Cartesian Tree.
   * Solution:
   */

  /**
   * 80.
   * Problem: Cartesian Tree Sorting.
   * Solution:
   */

  /**
   * 81.
   * Problem: Tarjan&#8217;s off-line lowest common ancestors algorithm.
   * Solution:
   */

  /**
   * 82.
   * Problem: Disjoint Set Data Structures (Java Implementation).
   * Solution:
   */

  /**
   * 83.
   * Problem: GCDs of given index ranges in an array.
   * Solution:
   */

  /**
   * 84.
   * Problem: Smallest Subarray with given GCD.
   * Solution:
   */

  /**
   * 85.
   * Problem: Longest Common Prefix | Set 5 (Using Trie).
   * Solution:
   */

  /**
   * 86.
   * Problem: Find last unique URL from long list of URLs in single traversal.
   * Solution:
   */

  /**
   * 87.
   * Problem: Find the number of Islands | Set 2 (Using Disjoint Set).
   * Solution:
   */

  /**
   * 88.
   * Problem: Efficiently design Insert, Delete and Median queries on a set.
   * Solution:
   */

  /**
   * 89.
   * Problem: Counting Triangles in a Rectangular space using BIT.
   * Solution:
   */

  /**
   * 90.
   * Problem: Two Dimensional Binary Indexed Tree or Fenwick Tree.
   * Solution:
   */

  /**
   * 91.
   * Problem: Longest Common Extension / LCE | Set 2 ( Reduction to RMQ).
   * Solution:
   */

  /**
   * 92.
   * Problem: Querying the number of distinct colors in a subtree of a colored tree using BIT.
   * Solution:
   */

  /**
   * 93.
   * Problem: Range LCM Queries.
   * Solution:
   */

  /**
   * 94.
   * Problem: Print all words matching a pattern in CamelCase Notation Dictonary.
   * Solution:
   */

  /**
   * 95.
   * Problem: Min-Max Range Queries in Array.
   * Solution:
   */

  /**
   * 96.
   * Problem: Binary Indexed Tree : Range Updates and Point Queries.
   * Solution:
   */

  /**
   * 97.
   * Problem: Count and Toggle Queries on a Binary Array.
   * Solution:
   */

  /**
   * 98.
   * Problem: Binary Indexed Tree : Range Update and Range Queries.
   * Solution:
   */

  /**
   * 99.
   * Problem: Implement a Phone Directory.
   * Solution:
   */

  /**
   * 100.
   * Problem: proto van Emde Boas Trees | Set 1 (Background and Introduction).
   * Solution:
   */

  /**
   * 101.
   * Problem: Unrolled Linked List | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 102.
   * Problem: Summed Area Table &#8211; Submatrix Summation.
   * Solution:
   */

  /**
   * 103.
   * Problem: Count of distinct substrings of a string using Suffix Trie.
   * Solution:
   */

  /**
   * 104.
   * Problem: Second minimum element using minimum comparisons.
   * Solution:
   */

  /**
   * 105.
   * Problem: Count inversion pairs in a matrix.
   * Solution:
   */

  /**
   * 106.
   * Problem: Count of distinct substrings of a string using Suffix Array.
   * Solution:
   */

  /**
   * 107.
   * Problem: Find pair of rows in a binary matrix that has maximum bit difference.
   * Solution:
   */

  /**
   * 108.
   * Problem: LCA for general or n-ary trees  (Sparse Matrix DP approach < O(nlogn), O(logn)>).
   * Solution:
   */

  /**
   * 109.
   * Problem: Weighted Prefix Search.
   * Solution:
   */

  /**
   * 110.
   * Problem: Queries on substring palindrome formation.
   * Solution:
   */

  /**
   * 111.
   * Problem: Sqrt (or Square Root) Decomposition | Set 2 (LCA of Tree in O(sqrt(height)) time).
   * Solution:
   */

  /**
   * 112.
   * Problem: Persistent Segment Tree | Set 1 (Introduction).
   * Solution:
   */

  /**
   * 113.
   * Problem: Boggle | Set 2 (Using Trie).
   * Solution:
   */

  /**
   * 114.
   * Problem: ScapeGoat Tree | Set 1 (Introduction and Insertion).
   * Solution:
   */

  /**
   * 115.
   * Problem: LCA for n-ary Tree | Constant Query O(1).
   * Solution:
   */

  /**
   * 116.
   * Problem: Print all valid words that are possible using Characters of Array.
   * Solution:
   */

  /**
   * 117.
   * Problem: Palindrome pair in an array of words (or strings).
   * Solution:
   */

  /**
   * 118.
   * Problem: Word formation using concatenation of two dictionary words.
   * Solution:
   */

  /**
   * 119.
   * Problem: Palindromic Tree | Introduction &amp; Implementation.
   * Solution:
   */

  /**
   * 120.
   * Problem: BK-Tree | Introduction &amp; Implementation.
   * Solution:
   */

  /**
   * 121.
   * Problem: Substring with highest frequency length product.
   * Solution:
   */

  /**
   * 122.
   * Problem: Print Kth character in sorted concatenated substrings of a string.
   * Solution:
   */

  /**
   * 123.
   * Problem: Find whether a subarray is in form of a mountain or not.
   * Solution:
   */

  /**
   * 124.
   * Problem: Left-Child Right-Sibling Representation of Tree.
   * Solution:
   */

  /**
   * 125.
   * Problem: Ropes Data Structure (Fast String Concatenation).
   * Solution:
   */

  /**
   * 126.
   * Problem: Reconstructing Segment Tree.
   * Solution:
   */

  /**
   * 127.
   * Problem: Dynamic Connectivity | Set 1 (Incremental).
   * Solution:
   */

  /**
   * 128.
   * Problem: Auto-complete feature using Trie.
   * Solution:
   */

  /**
   * 129.
   * Problem: Number of elements less than or equal to a given number in a given subarray.
   * Solution:
   */

  /**
   * 130.
   * Problem: Quad Tree.
   * Solution:
   */

  /**
   * 131.
   * Problem: Splay Tree | Set 3 (Delete).
   * Solution:
   */

  /**
   * 132.
   * Problem: Merge Sort Tree (Smaller or equal elements in given row range).
   * Solution:
   */

  /**
   * 133.
   * Problem: Segment Tree | Set 3 (XOR of given range).
   * Solution:
   */

  /**
   * 134.
   * Problem: Number of elements less than or equal to a given number in a given subarray | Set 2 (Including Updates).
   * Solution:
   */

  /**
   * 135.
   * Problem: Queries for number of distinct elements  in a subarray.
   * Solution:
   */

  /**
   * 136.
   * Problem: Image Manipulation Using Quadtrees.
   * Solution:
   */

}
