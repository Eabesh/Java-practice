package data.structures.stack;

import java.util.Stack;

public class StackExamples {


  /** 1. Problem: Level order traversal in spiral form. */

  /** 2. Problem: Implement Queue using Stacks. */

  /** 3. Problem: Check for balanced parentheses in an expression. */

  /** 4. Problem: Reverse a stack using recursion. */

  /** 5. Problem: Next Greater Element. */

  /** 6. Problem: Spaghetti Stack. */

  /** 7. Problem: Design and Implement Special Stack Data Structure | Added Space Optimized Version. */

  /** 8. Problem: Implement two stacks in an array. */

  /** 9. Problem: The Celebrity Problem. */

  /** 10. Problem: Construct BST from given preorder traversal | Set 2. */

  /** 11. Problem: Implement Stack using Queues. */

  /** 12. Problem: The Stock Span Problem. */

  /** 13. Problem: Iterative Postorder Traversal | Set 1 (Using Two Stacks). */

  /** 14. Problem: Iterative Postorder Traversal | Set 2 (Using One Stack). */

  /** 15. Problem: Merge Overlapping Intervals. */

  /** 16. Problem: Stack | Set 2 (Infix to Postfix). */

  /** 17. Problem: Largest Rectangular Area in a Histogram | Set 1. */

  /** 18. Problem: Largest Rectangular Area in a Histogram | Set 2. */

  /** 19. Problem: Expression Evaluation. */

  /** 20. Problem: Design a stack with operations on middle element. */

  /** 21. Problem: Print ancestors of a given binary tree node without recursion. */

  /** 22. Problem: Stack | Set 3 (Reverse a string using stack). */

  /** 23. Problem: Program for Tower of Hanoi. */

  /** 24. Problem: Stack | Set 4 (Evaluation of Postfix Expression). */

  /** 25. Problem: How to efficiently implement k stacks in a single array?. */

  /** 26. Problem: How to create mergable stack?. */

  /** 27. Problem: Find maximum depth of nested parenthesis in a string. */

  /** 28. Problem: One97 Interview Experience | Set 3 (Backend/Node js Developer). */

  /** 29. Problem: Iterative Tower of Hanoi. */

  /** 30. Problem: Flipkart Interview Experience | Set 24. */

  /** 31. Problem: Find the nearest smaller numbers on left side in an array. */

  /** 32. Problem: Remove repeated digits in a given number. */

  /** 33. Problem: Walmart labs interview | Set 4 (For Senior Software Engineer). */

  /** 34. Problem: MakeMyTrip Interview Experience | Set 9 (Off-Campus for Sr. Android developer)). */

  /** 35. Problem: Find maximum of minimum for every window size in a given array. */

  /** 36. Problem: Length of the longest valid substring. */

  /** 37. Problem: Sort a stack using recursion. */

  /** 38. Problem: Iterative Depth First Traversal of Graph. */

  /** 39. Problem: Minimum number of bracket reversals needed to make an expression balanced. */

  /** 40. Problem: Check if a given array can represent Preorder Traversal of Binary Search Tree. */

  /** 41. Problem: Walmart Lab Interview Experience | Set 8 (Off-Campus 3 Years Experience). */

  /** 42. Problem: MAQ Software Interview Experience | Set 10 (On-Campus). */

  /** 43. Problem: Form minimum number from given sequence. */

  /** 44. Problem: Stack Class in Java. */

  /** 45. Problem: Maximum size rectangle binary sub-matrix with all 1s. */

  /** 46. Problem: Check if two trees are Mirror. */

  /** 47. Problem: Design a stack that supports getMin() in O(1) time and O(1) extra space. */

  /** 48. Problem: Implement a stack using single queue. */

  /** 49. Problem: MakeMyTrip Interview Experience | Set 11 (Developer Position). */

  /** 50. Problem: Intuit Interview Experience | Set 11 (On-Campus). */

  /** 51. Problem: Find if an expression has duplicate parenthesis or not. */

  /** 52. Problem: VMware Interview Experience | Set 5 (On-Campus for IT Application Developer). */

  /** 53. Problem: Accolite Interview Experience | Set 13 (On-Campus for Internship and FTE). */

  /** 54. Problem: VMware Interview Experience | Set 6 (On-Campus for IT Application Developer). */

  /** 55. Problem: VMware Interview Experience | Set 7 (On-Campus for IT Application Developer). */

  /** 56. Problem: Directi Interview Experience | Set 15 (1st Round of On-Campus). */

  /** 57. Problem: Find maximum difference between nearest left and right smaller elements. */

  /** 58. Problem: Paytm Interview Experience | Set 10 (For Experienced). */

  /** 59. Problem: Find next Smaller of next Greater in an array. */

  /** 60. Problem: Find maximum sum possible equal sum of three stacks. */

  /** 61. Problem: Count natural numbers whose all permutation are greater than that number. */

  /** 62. Problem: Maximum sum of smallest and second smallest in an array. */

  /** 63. Problem: Stack Data Structure (Introduction and Program). */

  /** 64. Problem: How to implement stack using priority queue or heap?. */

  /** 65. Problem: Delete consecutive same words in a sequence. */

  /** 66. Problem: Decode a string recursively encoded as count followed by substring. */

  /** 67. Problem: Bubble sort using two Stacks. */

  /** 68. Problem: Pattern Occurrences : Stack Implementation Java. */

  /** 69. Problem: Hike Interview Experience | Set 5. */

  /** 70. Problem: Sort a stack using a temporary stack. */

  /** 71. Problem: Adobe Interview Experience | Set 47. */

  /** 72. Problem: OLA Interview Experience | Set 12. */

  /** 73. Problem: Amazon Interview Experience | Set 357 (For 2.5 Years Experienced). */

  /** 74. Problem: Create a customized data structure which evaluates functions in O(1). */

  /** 75. Problem: Oracle Interview Experience | Set 45. */

  /** 76. Problem: Iterative method to find ancestors of a given binary tree. */

  /** 77. Problem: Stack Permutations (Check if an array is stack permutation of other). */

  /** 78. Problem: Tracking current Maximum Element in a Stack. */

  /** 79. Problem: Adobe Interview Experience | Set 48 (On-Campus). */

  /** 80. Problem: Check mirror in n-ary tree. */

  /** 81. Problem: Reverse a number using stack. */

  /** 82. Problem: Reversing the first K elements of a Queue. */

  /** 83. Problem: Amazon interview experience | Set 384 (On-Campus for FTE). */

  /** 84. Problem: Reversing a Queue. */

  /** 85. Problem: Yatra.com Interview Experience | Set 7. */

  /** 86. Problem: Check  if stack elements are pairwise consecutive. */

  /** 87. Problem: Interleave the first half of the queue with second half. */

  /** 88. Problem: Remove brackets from an algebraic string containing + and &#8211; operators. */

  /** 89. Problem: Reverse a stack without using extra space in O(n). */

  /** 90. Problem: Print next greater number of Q queries. */

  /** 91. Problem: Simplify the directory path (Unix like). */

  /** 92. Problem: Next Greater Frequency Element. */

  /** 93. Problem: Number of NGEs to the right. */

  /** 94. Problem: Construct Binary Tree from String with bracket representation. */

  /** 95. Problem: Check if two expressions with brackets are same. */

  /** 96. Problem: Find index of closing bracket for a given opening bracket in an expression. */

  /** 97. Problem: Microsoft Interview Experience | Set 151 (SDE-2 3.5 years experience). */

  /** 98. Problem: Identify and mark unmatched parenthesis in an expression. */

  /** 99. Problem: Count subarrays where second highest lie before highest. */

  /** 100. Problem: ZigZag Tree Traversal. */

  /** 101. Problem: Convert Infix To Prefix Notation. */

  /** 102. Problem: Print Reverse a linked list using Stack. */

  /** 103. Problem: Evaluation of Prefix Expressions. */

  /** 104. Problem: Check if an array is stack sortable. */

  /** 105. Problem: Growable array based stack. */

  /** 106. Problem: Implement Stack and Queue using Deque. */

  /** 107. Problem: Reverse individual words. */

  /** 108. Problem: Stack and Queue in Python using queue Module. */

  /** 109. Problem: Alternate Odd and Even Nodes in a Singly Linked List. */

  /** 110. Problem: Expression contains redundant bracket or not. */

  /** 111. Problem: Modify a binary tree to get preorder traversal using right pointers only. */

  /** 112. Problem: Postfix to Infix. */

  /** 113. Problem: Postfix to Prefix Conversion. */

  /** 114. Problem: Prefix to Postfix Conversion. */

  /** 115. Problem: Prefix to Infix Conversion. */

  /** 116. Problem: Flipkart Interview Experience | Set 49. */

  /** 117. Problem: Print Bracket Number. */

  /** 118. Problem: Delete middle element of a stack. */

  /** 119. Problem: Delete array elements which are smaller than next or become smaller. */

  /** 120. Problem: Range Queries for Longest Correct Bracket Subsequence. */

  /** 121. Problem: Balanced expression with replacement. */

  /** 122. Problem: Level order traversal with direction change after every two levels. */

  /** 123. Problem: Sorting array using Stacks. */

  /** 124. Problem: Check if a queue can be sorted into another queue using a stack. */

  /** 125. Problem: Maximum product of indexes of next greater on left and right. */

  /** 126. Problem: Range Queries for Longest Correct Bracket Subsequence Set | 2. */

  /** 127. Problem: Merging and Sorting Two Unsorted Stacks. */

  /** 128. Problem: Design a stack to retrieve original elements and return the minimum element in O(1) time and O(1) space. */

  /** 129. Problem: Check for balanced parenthesis without using stack. */



  /**
   * 8.
   * Problem: The Celebrity Problem
   * In a party of N people, only one person is known to everyone. Such a person may be present in the party,
   * if yes, (s)he doesn’t know anyone in the party. We can only ask questions like “does A know B? “.
   * Find the stranger (celebrity) in minimum number of questions.
   * Solution: The idea is to use two pointers, one from start and one from the end. Assume the start person is A,
   * and the end person is B. If A knows B, then A must not be the celebrity. Else, B must not be the celebrity.
   * We will find a celebrity candidate at the end of the loop. Go through each person again and check whether
   * this is the celebrity.
   */
  int findCeleb(int[][] matrix) {
    int a = 0;
    int b = matrix.length - 1;
    while (a < b) {
      if (knows(matrix,a,b)) a++;
      else b--;
    }
    for (int i = 0; i < matrix.length; i++) {
      if (i != a)
        if (knows(matrix,a,i) || !knows(matrix,i,a)) return -1;
    }
    return a;
  }

  private boolean knows(int[][] m, int a, int b) { return m[a][b] == 1 ;}






  /**
   * 1.
   * Problem: Implement Queue using Stacks.
   * Solution:
   */

  class MyQueue{

    Stack<Integer> stack1, stack2;

    public MyQueue() {
      stack1 = new Stack<>();
      stack2 = new Stack<>();
    }

    void enque(int x) {
      stack1.push(x);
    }

    int deque() {
      reverseStack(stack1, stack2);
      int front =  stack2.pop();
      reverseStack(stack2, stack1);
      return front;
    }

    int peek() {
      reverseStack(stack1, stack2);
      int front =  stack2.peek();
      reverseStack(stack2, stack1);
      return front;
    }


    boolean empty() {
      return stack1.isEmpty();
    }

    private void reverseStack(Stack<Integer> stack1, Stack<Integer> stack2) {
      while (!stack1.isEmpty()) stack2.push(stack1.pop());
    }
  }

  /**
   * 2.
   * Problem: Check for balanced parentheses in an expression.
   * Solution:
   */

  /**
   * 3.
   * Problem: Reverse a stack using recursion.
   * Solution:
   */

  /**
   * 4.
   * Problem: Next Greater Element.
   * Solution:
   */

  /**
   * 5.
   * Problem: Spaghetti Stack.
   * Solution:
   */

  /**
   * 6.
   * Problem: Design and Implement Special Stack Data Structure | Added Space Optimized Version.
   * Solution:[Adobe]
   * Use two stacks: one to store actual stack elements and other as an auxiliary stack to
   * store minimum values. The idea is to do push() and pop() operations in such a way that the
   * top of auxiliary stack is always the minimum.
   */
  class SpecialStack {
    Stack<Integer> minStack = new Stack<>();
    Stack<Integer> stack = new Stack<>();

    void push(int ele) {
      if (stack.isEmpty()) {
        stack.push(ele);
        minStack.push(ele);
      } else {
        stack.push(ele);
        if (minStack.peek() >= ele) minStack.push(ele);
      }
    }

    int pop() {
      int x = stack.pop();
      if (minStack.peek() == x) minStack.pop();
      return x;
    }

    int getMin() {
      return minStack.peek();
    }
  }



  /**
   * 7.
   * Problem: Implement two stacks in an array.
   * Solution:
   */

  /**
   * 8.
   * Problem: The Celebrity Problem.
   * Solution:
   */

  /**
   * 9.
   * Problem: Implement Stack using Queues.
   * Solution:
   */

  /**
   * 10.
   * Problem: The Stock Span Problem.
   * Solution:
   */

  /**
   * 11.
   * Problem: Iterative Postorder Traversal | Set 1 (Using Two Stacks).
   * Solution:
   */

  /**
   * 12.
   * Problem: Iterative Postorder Traversal | Set 2 (Using One Stack).
   * Solution:
   */

  /**
   * 13.
   * Problem: Merge Overlapping Intervals.
   * Solution:
   */

  /**
   * 14.
   * Problem: Stack | Set 2 (Infix to Postfix).
   * Solution:
   */


   String infixToPostFix(String exp) {
     String postFix = "";
     Stack<Character> stack = new Stack<>();

    for (char c : exp.toCharArray()) {
      if (Character.isLetterOrDigit(c)) postFix += c;
      else if (c == '(') stack.push(c);
      else if (c ==')') {
        while (!stack.isEmpty() && stack.peek() != '(') postFix += stack.pop();

        if (!stack.isEmpty() && stack.peek() != '(') return "Invalid Expression";
        else stack.pop();
      }
      else {
        while (!stack.isEmpty() && precedence(c) < precedence(stack.peek())) postFix += stack.pop();
        stack.push(c);
      }
    }
    while (!stack.isEmpty()) postFix += stack.pop();
    return postFix;
   }

  private int precedence(Character ch) {
    if (ch == '+' || ch == '-') return 1;
    else if (ch == '*' || ch == '/') return 2;
    else if (ch == '^' || ch == '-') return 3;
    else return -1;
  }


  /**
   * 15.
   * Problem: Largest Rectangular Area in a Histogram | Set 2
   * Find the largest rectangular area possible in a given histogram where the largest rectangle can
   * be made of a number of contiguous bars. For simplicity, assume that all bars have same width
   * and the width is 1 unit.
   *
   * values: 6, 2, 5, 4, 5, 1, 6
   * indexStack 0, 1, 2
   * maxArea = 5
   * indexStack 0, 1, 3, 4
   *
   *
   */
  public int maxRectangleArea(int[] array) {
    Stack<Integer> indexStack = new Stack<>();
    int currIndex = 0, maxArea = -1;
    while (currIndex < array.length) {
      if (indexStack.isEmpty() || array[indexStack.peek()] <= array[currIndex]) indexStack.push(currIndex++);
      else maxArea = Math.max(calculateArea(array, indexStack, currIndex), maxArea);
    }
    while (!indexStack.isEmpty()) maxArea = Math.max(calculateArea(array, indexStack, currIndex), maxArea);
    return maxArea;
  }

  private int calculateArea(int[] array, Stack<Integer> indexStack, int currIndex) {
    int topIndex = indexStack.pop();
    if (indexStack.isEmpty()) return array[topIndex] * currIndex;
    else {
      int leftIndex = indexStack.peek();
      return array[topIndex] * (currIndex  - leftIndex - 1);
    }
  }

  /**
   * 16.
   * Problem: Expression Evaluation.
   */
  int evaluateExpression(String exp) {
    Stack<Integer> stackForOperands = new Stack<>();
    Stack<Character> stackForOperators = new Stack<>();
    String[] tokens = exp.split("\\s+");
    for (String token : tokens) {
      if(token.matches("-?\\d+")) stackForOperands.push(Integer.parseInt(token));
      else if ("(".equals(token)) stackForOperators.push(token.charAt(0));
      else if (")".equals(token)) {
        while (stackForOperators.peek() != '(') oneOperatorProcess(stackForOperands, stackForOperators);
        stackForOperators.pop();
      }
      else if ("+".equals(token) || "-".equals(token) || "*".equals(token) || "/".equals(token)) {
        while (!stackForOperators.isEmpty() && findPrecedence(token.charAt(0), stackForOperators.peek())) oneOperatorProcess(stackForOperands, stackForOperators);
        stackForOperators.push(token.charAt(0));
      }
    }

    while (!stackForOperators.isEmpty()) oneOperatorProcess(stackForOperands, stackForOperators);
    return stackForOperands.pop();
  }

  private  boolean findPrecedence(char op1, char op2)
  {
    if (op2 == '(' || op2 == ')') return false;
    else if ((op1 == '*' || op1 == '/') && (op2 == '+' || op2 == '-')) return false;
    else return true;
  }

  private void oneOperatorProcess(Stack<Integer> stackForOperands, Stack<Character> stackForOperators) {
    char operator = stackForOperators.pop();
    int b = stackForOperands.pop();
    int a = stackForOperands.pop();
    int result = 0;
    switch (operator) {
      case '+':
        result = a + b;
        break;
      case '-':
        result = a - b;
        break;

      case '*':
        result = a * b;
        break;

      case '/':
        result = a / b;
        break;
    }
    stackForOperands.push(result);
  }

  /**
   * 17.
   * Problem: Design a stack with operations on middle element.
   * Solution:
   */

  /**
   * 18.
   * Problem: Print ancestors of a given binary tree node without recursion.
   * Solution:
   */

  /**
   * 19.
   * Problem: Stack | Set 3 (Reverse a string using stack).
   * Solution:
   */

  /**
   * 20.
   * Problem: Program for Tower of Hanoi.
   * Solution:
   */

  /**
   * 21.
   * Problem: Stack | Set 4 (Evaluation of Postfix Expression).
   * Solution:
   */

  /**
   * 22.
   * Problem: How to efficiently implement k stacks in a single array?.
   * Solution:
   */

  /**
   * 23.
   * Problem: How to create mergable stack?.
   * Solution:
   */

  /**
   * 24.
   * Problem: Find maximum depth of nested parenthesis in a string.
   * Solution:
   */

  /**
   * 25.
   * Problem: Iterative Tower of Hanoi.
   * Solution:
   */

  /**
   * 26.
   * Problem: Find maximum of minimum for every window size in a given array.
   * Solution:
   */

  /**
   * 27.
   * Problem: Length of the longest valid substring.
   * Solution:
   */

  /**
   * 28.
   * Problem: Sort a stack using recursion.
   * Solution:
   */

  /**
   * 29.
   * Problem: Iterative Depth First Traversal of Graph.
   * Solution:
   */

  /**
   * 30.
   * Problem: Minimum number of bracket reversals needed to make an expression balanced.
   * Solution:
   */

  /**
   * 31.
   * Problem: Check if a given array can represent Preorder Traversal of Binary Search Tree.
   * Solution:
   */

  /**
   * 32.
   * Problem: Form minimum number from given sequence.
   * Solution:
   */

  /**
   * 33.
   * Problem: Stack Class in Java.
   * Solution:
   */

  /**
   * 34.
   * Problem: Design a stack that supports getMin() in O(1) time and O(1) extra space.
   * Solution:
   */



  /**
   * 35.
   * Problem: Implement a stack using single queue.
   * Solution:
   */

  /**
   * 36.
   * Problem: Find if an expression has duplicate parenthesis or not.
   * Solution:
   */

  /**
   * 37.
   * Problem: Find maximum difference between nearest left and right smaller elements.
   * Solution:
   */

  /**
   * 38.
   * Problem: Find next Smaller of next Greater in an array.
   * Solution:
   */

  /**
   * 39.
   * Problem: Find maximum sum possible equal sum of three stacks.
   * Solution:
   */

  /**
   * 40.
   * Problem: Count natural numbers whose all permutation are greater than that number.
   * Solution:
   */

  /**
   * 41.
   * Problem: Stack Data Structure (Introduction and Program).
   * Solution:
   */

  /**
   * 42.
   * Problem: How to implement stack using priority queue or heap?.
   * Solution:
   */

  /**
   * 43.
   * Problem: Delete consecutive same words in a sequence.
   * Solution:
   */

  /**
   * 44.
   * Problem: Decode a string recursively encoded as count followed by substring.
   * Solution:
   */

  /**
   * 45.
   * Problem: Bubble sort using two Stacks.
   * Solution:
   */

  /**
   * 46.
   * Problem: Pattern Occurrences : Stack Implementation Java.
   * Solution:
   */

  /**
   * 47.
   * Problem: Sort a stack using a temporary stack.
   * Solution:
   */

  /**
   * 48.
   * Problem: Create a customized data structure which evaluates functions in O(1).
   * Solution:
   */

  /**
   * 49.
   * Problem: Iterative method to find ancestors of a given binary tree.
   * Solution:
   */

  /**
   * 50.
   * Problem: Stack Permutations (Check if an array is stack permutation of other).
   * Solution:
   */

  /**
   * 51.
   * Problem: Tracking current Maximum Element in a Stack.
   * Solution:
   */

  /**
   * 52.
   * Problem: Check mirror in n-ary tree.
   * Solution:
   */

  /**
   * 53.
   * Problem: Reverse a number using stack.
   * Solution:
   */

  /**
   * 54.
   * Problem: Reversing the first K elements of a Queue.
   * Solution:
   */

  /**
   * 55.
   * Problem: Reversing a Queue.
   * Solution:
   */

  /**
   * 56.
   * Problem: Check  if stack elements are pairwise consecutive.
   * Solution:
   */

  /**
   * 57.
   * Problem: Interleave the first half of the queue with second half.
   * Solution:
   */

  /**
   * 58.
   * Problem: Remove brackets from an algebraic string containing + and &#8211; operators.
   * Solution:
   */

  /**
   * 59.
   * Problem: Reverse a stack without using extra space in O(n).
   * Solution:
   */

  /**
   * 60.
   * Problem: Print next greater number of Q queries.
   * Solution:
   */

  /**
   * 61.
   * Problem: Simplify the directory path (Unix like).
   * Solution:
   */

  /**
   * 62.
   * Problem: Next Greater Frequency Element.
   * Solution:
   */

  /**
   * 63.
   * Problem: Number of NGEs to the right.
   * Solution:
   */

  /**
   * 64.
   * Problem: Construct Binary Tree from String with bracket representation.
   * Solution:
   */

  /**
   * 65.
   * Problem: Check if two expressions with brackets are same.
   * Solution:
   */

  /**
   * 66.
   * Problem: Find index of closing bracket for a given opening bracket in an expression.
   * Solution:
   */

  /**
   * 67.
   * Problem: Identify and mark unmatched parenthesis in an expression.
   * Solution:
   */

  /**
   * 68.
   * Problem: Count subarrays where second highest lie before highest.
   * Solution:
   */

  /**
   * 69.
   * Problem: ZigZag Tree Traversal.
   * Solution:
   */

  /**
   * 70.
   * Problem: Convert Infix To Prefix Notation.
   * Solution:
   */

  /**
   * 71.
   * Problem: Print Reverse a linked list using Stack

   * Solution:
   */

  /**
   * 72.
   * Problem: Evaluation of Prefix Expressions

   * Solution:
   */

  /**
   * 73.
   * Problem: Check if an array is stack sortable

   * Solution:
   */

  /**
   * 74.
   * Problem: Growable array based stack

   * Solution:
   */


  /**
   * 75.
   * Problem: Implement Stack and Queue using Deque

   * Solution:
   */


  /**
   * 76.
   * Problem: Reverse individual words

   * Solution:
   */

  /**
   * 77.
   * Problem: Stack and Queue in Python using queue Module

   * Solution:
   */

  /**
   * 78.
   * Problem: Alternate Odd and Even Nodes in a Singly Linked List

   * Solution:
   */

  /**
   * 79.
   * Problem: Expression contains redundant bracket or not

   * Solution:
   */

  /**
   * 80.
   * Problem: Modify a binary tree to get preorder traversal using right pointers only

   * Solution:
   */


  /**
   * 81.
   * Problem: Postfix to Infix
   * Solution:
   */
  String postFixToInfix(String postFix) {
    Stack<String> stack = new Stack<>();
    for (char c : postFix.toCharArray()) {
      if (Character.isLetterOrDigit(c)) stack.push(String.valueOf(c));
      else {
        String op1 = stack.pop();
        String op2 = stack.pop();
        stack.push("(" + op2 + c + op1 + ")");
      }
    }
    return stack.pop();
  }

  /** 82. Problem: Postfix to Prefix Conversion Solution: */

  /** 83. Problem: Prefix to Postfix Conversion Solution: */

  /**
   * 84. Problem: Prefix to Infix Conversion
   *
   * <p>Solution:
   */

  /** 85. Problem: Print Bracket Number Solution: */

  // Leetcode
  /**
   * 1. Problem: Write a program for finding duplicate parenthesis in a expression.
   * For example : (( a + b ) + (( c + d ))) = a + b + c + d
   * (( a + b ) * (( c + d ))) = (a + b) * (c + d)
   * Solution: 1. Infix to postfix  2. postFix to inFix.
   */



}
