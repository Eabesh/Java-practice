package algorithms.sorting;

class SortingExamples {

  /** 1. Problem: Sort elements by frequency | Set 1. */

  /** 2. Problem: Count Inversions in an array | Set 1 (Using Merge Sort). */

  /** 3. Problem: Merge Sort for Linked Lists. */

  /** 4. Problem: Sort an array of 0s, 1s and 2s. */

  /** 5. Problem: Find the Minimum length Unsorted Subarray, sorting which makes the complete array sorted. */

  /** 6. Problem: When does the worst case of Quicksort occur?. */

  /** 7. Problem: Stability in sorting algorithms. */

  /** 8. Problem: Which sorting algorithm makes minimum number of memory writes?. */

  /** 9. Problem: Lower bound for comparison based sorting algorithms. */

  /** 10. Problem: Find whether an array is subset of another array | Added Method 3. */

  /** 11. Problem: Find four elements that sum to a given value | Set 2 ( O(n^2Logn) Solution). */

  /** 12. Problem: Sort a nearly sorted (or K sorted) array. */

  /** 13. Problem: Sort numbers stored on different machines. */

  /** 14. Problem: Iterative Quick Sort. */

  /** 15. Problem: Sort a linked list of 0s, 1s and 2s. */

  /** 16. Problem: Pancake sorting. */

  /** 17. Problem: A Pancake Sorting Problem. */

  /** 18. Problem: Insertion Sort. */

  /** 19. Problem: Merge Sort. */

  /** 20. Problem: Heap Sort. */

  /** 21. Problem: Counting Sort. */

  /** 22. Problem: Comparator function of qsort() in C. */

  /** 23. Problem: QuickSort on Doubly Linked List. */

  /** 24. Problem: Sort elements by frequency | Set 2. */

  /** 25. Problem: QuickSort on Singly Linked List. */

  /** 26. Problem: Radix Sort. */

  /** 27. Problem: Find number of pairs (x, y) in an array such that x^y > y^x. */

  /** 28. Problem: Count all distinct pairs with difference equal to k. */

  /** 29. Problem: Python Program for QuickSort. */

  /** 30. Problem: Java Program for QuickSort. */

  /** 31. Problem: C++ Program for QuickSort. */

  /** 32. Problem: QuickSort. */

  /** 33. Problem: Selection Sort. */

  /** 34. Problem: C Program for Bubble Sort on Linked List. */

  /** 35. Problem: Python Program for Bubble Sort. */

  /** 36. Problem: Bubble Sort. */

  /** 37. Problem: Java Program for Bubble Sort. */

  /** 38. Problem: C++ Program for Bubble Sort. */

  /** 39. Problem: C Program for Bubble Sort. */

  /** 40. Problem: Sort n numbers in range from 0 to n^2 &#8211; 1 in linear time. */

  /** 41. Problem: Bucket Sort. */

  /** 42. Problem: C Program to Sort an array of names or strings. */

  /** 43. Problem: ShellSort. */

  /** 44. Problem: Sorting Terminology. */

  /** 45. Problem: Binary Insertion Sort. */

  /** 46. Problem: Python Program for Binary Insertion Sort. */

  /** 47. Problem: Java Program for Binary Insertion Sort. */

  /** 48. Problem: C Program for Binary Insertion Sort. */

  /** 49. Problem: Sort an array according to the order defined by another array. */

  /** 50. Problem: Given a sorted array and a number x, find the pair in array whose sum is closest to x. */

  /** 51. Problem: Time complexity of insertion sort when there are O(n) inversions?. */

  /** 52. Problem: Sort an array in wave form. */

  /** 53. Problem: Can QuickSort be implemented in O(nLogn) worst case time complexity?. */

  /** 54. Problem: Python Program for Iterative Merge Sort. */

  /** 55. Problem: Iterative Merge Sort. */

  /** 56. Problem: Java Program for Iterative Merge Sort. */

  /** 57. Problem: Check if any two intervals overlap among a given set of intervals. */

  /** 58. Problem: Merge Sort for Doubly Linked List. */

  /** 59. Problem: Why Quick Sort preferred for Arrays and Merge Sort for Linked Lists?. */

  /** 60. Problem: How to efficiently sort a big list dates in 20&#8217;s. */

  /** 61. Problem: Sort an almost sorted array where only two elements are swapped. */

  /** 62. Problem: Where is Heap Sort used practically?. */

  /** 63. Problem: Find memory conflicts among multiple threads. */

  /** 64. Problem: Find the point where maximum intervals overlap. */

  /** 65. Problem: How to sort a big array with many repetitions?. */

  /** 66. Problem: Sort a linked list that is sorted alternating ascending and descending orders?. */

  /** 67. Problem: 3-Way QuickSort (Dutch National Flag). */

  /** 68. Problem: C++ program for Sorting Dates using Selection Sort. */

  /** 69. Problem: How to sort an array of dates in C/C++?. */

  /** 70. Problem: Sorting Strings using Bubble Sort. */

  /** 71. Problem: Comb Sort. */

  /** 72. Problem: Pigeonhole Sort. */

  /** 73. Problem: QuickSort Tail Call Optimization (Reducing worst case space to Log n ). */

  /** 74. Problem: std::sort() in C++ STL. */

  /** 75. Problem: Find minimum difference between any two elements. */

  /** 76. Problem: Convert an array to reduced form | Set 1 (Simple and Hashing). */

  /** 77. Problem: External Sorting. */

  /** 78. Problem: Cartesian Tree Sorting. */

  /** 79. Problem: Maximum product of a triplet (subsequnece of size 3) in array. */

  /** 80. Problem: Find missing elements of a range. */

  /** 81. Problem: Find a permutation that causes worst case of Merge Sort. */

  /** 82. Problem: C qsort() vs C++ sort(). */

  /** 83. Problem: Bitonic Sort. */

  /** 84. Problem: Minimum sum of two numbers formed from digits of an array. */

  /** 85. Problem: Cocktail Sort. */

  /** 86. Problem: Know Your Sorting Algorithm | Set 1 (Sorting Weapons used by Programming Languages). */

  /** 87. Problem: Know Your Sorting Algorithm | Set 2  (Introsort- C++’s Sorting Weapon). */

  /** 88. Problem: Sleep Sort – The King of Laziness / Sorting while Sleeping. */

  /** 89. Problem: Gnome Sort. */

  /** 90. Problem: Sorting Vector of Pairs in C++ | Set 1 (Sort by first and second). */

  /** 91. Problem: Sorting Vector of Pairs in C++ | Set 2 (Sort in descending order by first and second). */

  /** 92. Problem: Odd-Even Sort / Brick Sort. */

  /** 93. Problem: BogoSort or Permutation Sort. */

  /** 94. Problem: Sorting 2D Vector in C++ | Set 2 (In descending order by row and column). */

  /** 95. Problem: Sorting 2D Vector in C++ | Set 3 (By number of columns). */

  /** 96. Problem: Find Surpasser Count of each element in array. */

  /** 97. Problem: Rearrange positive and negative numbers with constant extra space. */

  /** 98. Problem: Sort an array according to count of set bits. */

  /** 99. Problem: Structure Sorting (By Multiple Rules) in C++. */

  /** 100. Problem: Time Complexities of all Sorting Algorithms. */

  /** 101. Problem: Count distinct occurrences as a subsequence. */

  /** 102. Problem: Tree Sort. */

  /** 103. Problem: Minimum number of swaps required to sort an array. */

  /** 104. Problem: Number of swaps to sort when only adjacent swapping allowed. */

  /** 105. Problem: Minimum swaps to make two arrays identical. */

  /** 106. Problem: Find elements larger than half of the elements in an array. */

  /** 107. Problem: Count minimum number of subsets (or subsequences) with consecutive numbers. */

  /** 108. Problem: Sum of all elements between k1&#8217;th and k2&#8217;th smallest elements. */

  /** 109. Problem: Number of sextuplets (or six values) that satisfy an equation. */

  /** 110. Problem: Sort an array according to absolute difference with given value. */

  /** 111. Problem: Minimize the sum of product of two arrays with permutations allowed. */

  /** 112. Problem: Position of an element after stable sort. */

  /** 113. Problem: Asymptotic Analysis and comparison of sorting algorithms. */

  /** 114. Problem: Chocolate Distribution Problem. */

  /** 115. Problem: Sort even-placed elements in increasing and odd-placed in decreasing order. */

  /** 116. Problem: Permute two arrays such that sum of every pair is greater or equal to K. */

  /** 117. Problem: Choose k array elements such that difference of maximum and minimum is minimized. */

  /** 118. Problem: Sort an array when two halves are sorted. */

  /** 119. Problem: Find pair with greatest product in array. */

  /** 120. Problem: Minimum swap required to convert binary tree to binary search tree. */

  /** 121. Problem: K-th smallest element after removing some integers from natural numbers. */

  /** 122. Problem: Check whether Arithmetic Progression can be formed from the given array. */

  /** 123. Problem: Cycle Sort. */

  /** 124. Problem: Python Program for Cycle Sort. */

  /** 125. Problem: Java Program for Cycle Sort. */

  /** 126. Problem: C++ Program for Cycle Sort. */

  /** 127. Problem: Hoare&#8217;s vs Lomuto partition scheme in QuickSort. */

  /** 128. Problem: Bucket Sort To Sort an Array with Negative Numbers. */

  /** 129. Problem: Tag Sort (To get both sorted and original). */

  /** 130. Problem: Possible to form a triangle from array values. */

  /** 131. Problem: Maximum difference between frequency of two elements such that element having greater frequency is also greater. */

  /** 132. Problem: Java Program for Recursive Bubble Sort. */

  /** 133. Problem: C++ Program for Recursive Bubble Sort. */

  /** 134. Problem: Recursive Bubble Sort. */

  /** 135. Problem: Check if reversing a sub array make the array sorted. */

  /** 136. Problem: Find all  triplets with zero sum. */

  /** 137. Problem: An Insertion Sort time complexity question. */

  /** 138. Problem: Sort a Matrix in all way increasing order. */

  /** 139. Problem: Sort array after converting elements to their squares. */

  /** 140. Problem: Sort all even numbers in ascending order and then sort all odd numbers in descending order. */

  /** 141. Problem: Recursive Insertion Sort. */

  /** 142. Problem: Python Program for Recursive Insertion Sort. */

  /** 143. Problem: Java Program for Recursive Insertion Sort. */

  /** 144. Problem: C Program for Recursive Insertion Sort. */

  /** 145. Problem: Sorting Big Integers. */

  /** 146. Problem: Sort an array of large numbers. */

  /** 147. Problem: Sort 3 Integers without using if condition or using only max() function. */

  /** 148. Problem: Minimum difference between max and min of all K-size subsets. */

  /** 149. Problem: Minimum swaps to reach permuted array with at most 2 positions left swaps allowed. */

  /** 150. Problem: Convert an array to reduced form | Set 2 (Using vector of pairs). */

  /** 151. Problem: Find sum of non-repeating (distinct) elements in an array. */

  /** 152. Problem: Minimum sum of absolute difference of pairs of two arrays. */

  /** 153. Problem: Find the largest multiple of 3 from array of digits | Set 2 (In O(n) time and O(1) space). */

  /** 154. Problem: C++ Program for Stooge Sort. */

  /** 155. Problem: Python Program for Stooge Sort. */

  /** 156. Problem: Stooge Sort. */

  /** 157. Problem: Java Program for Stooge Sort. */

  /** 158. Problem: Serial Sort v/s Parallel Sort in Java. */

  /** 159. Problem: 3-way Merge Sort. */

  /** 160. Problem: Noble integers in an array (count of greater elements is equal to value). */

  /** 161. Problem: Find maximum height pyramid from the given array of objects. */

  /** 162. Problem: Program to check if an array is sorted or not (Iterative and Recursive). */

  /** 163. Problem: Smallest Difference Triplet from Three arrays. */

  /** 164. Problem: Program to print an array in Pendulum Arrangement. */

  /** 165. Problem: Smallest Difference pair of values between two unsorted Arrays. */

  /** 166. Problem: Find whether it is possible to make array elements same using one external number. */

  /** 167. Problem: Sort an array of strings  according to string lengths. */

  /** 168. Problem: Check if it is possible to sort an array with conditional swapping of adjacent allowed. */

  /** 169. Problem: TimSort. */

  /** 170. Problem: Sort an array after applying the given equation. */

  /** 171. Problem: Print array of strings in sorted order without copying one string into another. */

  /** 172. Problem: Sort elements on the basis of number of factors. */

  /** 173. Problem: Delete consecutive same words in a sequence. */

  /** 174. Problem: Bead Sort | A Natural Sorting Algorithm. */

  /** 175. Problem: C program to sort an array of strings using Selection Sort. */

  /** 176. Problem: Sum of minimum absolute difference of each array element. */

  /** 177. Problem: Longest Common Prefix | Set 6 (Sorting). */

  /** 178. Problem: Find shortest unique prefix for every word in a given list | Set 2 (Using Sorting). */

  /** 179. Problem: Maximizing Unique Pairs from two arrays. */

  /** 180. Problem: Check whether a given array is a k sorted array or not. */

  /** 181. Problem: Bubble sort using two Stacks. */

  /** 182. Problem: Count pairs from two sorted arrays whose sum is equal to a given value x. */

  /** 183. Problem: Recursive Selection Sort. */

  /** 184. Problem: Alternative Sorting. */

  /** 185. Problem: Find a pair of elements swapping which makes sum of two arrays same. */

  /** 186. Problem: Sort a stack using a temporary stack. */

  /** 187. Problem: Count pairs from two linked lists whose sum is equal to a given value. */

  /** 188. Problem: Find the Sub-array with sum closest to 0. */

  /** 189. Problem: Maximum product of subsequence of size k. */

  /** 190. Problem: Count quadruples from four sorted arrays whose sum is equal to a given value x. */

  /** 191. Problem: Insertion Sort for Doubly Linked List. */

  /** 192. Problem: Sort the biotonic doubly linked list. */

  /** 193. Problem: Why is it faster to process sorted array than an unsorted array ?. */

  /** 194. Problem: Recursive selection sort for singly linked list | Swapping node links. */

  /** 195. Problem: Why quicksort is better than mergesort ?. */

  /** 196. Problem: Sorting Array Elements By Frequency | Set 3 (Using STL). */

  /** 197. Problem: Find first k natural numbers missing in given array. */

  /** 198. Problem: Merging two unsorted arrays in sorted order. */

  /** 199. Problem: Ways to sort list of dictionaries by values in Python – Using itemgetter. */

  /** 200. Problem: Minimum number of distinct elements after removing m items. */

  /** 201. Problem: Smallest element in an array that is repeated exactly &#8216;k&#8217; times.. */

  /** 202. Problem: Rearrange an array in order &#8211; smallest, largest, 2nd smallest, 2nd largest, ... */

  /** 203. Problem: Sort first half in ascending and second half in descending order. */

  /** 204. Problem: Insertion sort using C++ STL. */

  /** 205. Problem: Check if a grid can become row-wise and column-wise sorted after adjacent swaps. */

  /** 206. Problem: Sort a linked list of 0s, 1s and 2s by changing links. */

  /** 207. Problem: Sorting array of strings (or words) using Trie. */

  /** 208. Problem: Sort an array according to absolute difference with a given value &#8220;using constant extra space&#8221;. */

  /** 209. Problem: A sorting algorithm that slightly improves on selection sort. */

  /** 210. Problem: How to make Mergesort to perform O(n) comparisons in best case?. */

  /** 211. Problem: Dual pivot Quicksort. */

  /** 212. Problem: Sort elements by frequency | Set 4 (Efficient approach using hash). */

  /** 213. Problem: Maximum area rectangle by picking four sides from array. */

  /** 214. Problem: Check if given array is almost sorted (elements are at-most one position away). */

  /** 215. Problem: Sort a binary array using one traversal. */

  /** 216. Problem: Count points covered by given intervals. */

  /** 217. Problem: Difference between highest and least frequencies in an array. */

  /** 218. Problem: Sort string of characters. */

  /** 219. Problem: Minimum product pair an array of positive Integers. */

  /** 220. Problem: Stable Selection Sort. */

  /** 221. Problem: Circle Sort. */

  /** 222. Problem: Sort a Rotated Sorted Array. */

  /** 223. Problem: Pairs with Difference less than K. */

  /** 224. Problem: Maximize the sum of arr[i]*i. */

  /** 225. Problem: Sorting an array according to another array using pair in STL. */

  /** 226. Problem: Median after K additional integers. */

  /** 227. Problem: Rearrange positive and negative numbers using inbuilt sort function. */

  /** 228. Problem: Minimum cost to sort a matrix of numbers from 0 to n^2 &#8211; 1. */

  /** 229. Problem: Program to sort string in descending order. */

  /** 230. Problem: Job Sequencing Problem &#8211; Loss Minimization. */

  /** 231. Problem: Quickselect Algorithm. */

  /** 232. Problem: Minimum number of elements to add to make median equals x. */

  /** 233. Problem: Counting cross lines in an array. */

  /** 234. Problem: Elements to be added so that all elements of a range are present in array. */

  /** 235. Problem: Find array with k number of merge sort calls. */

  /** 236. Problem: Sort an array with swapping only with a special element is allowed. */

  /** 237. Problem: Sorting using trivial hash function. */

  /** 238. Problem: Number of visible boxes after putting one inside another. */

  /** 239. Problem: std::stable_sort() in C++ STL. */

  /** 240. Problem: Maximum array from two given arrays keeping order same. */

  /** 241. Problem: No of pairs (a[j] >= a[i]) with k numbers in range (a[i], a[j]) that are divisible by x. */

  /** 242. Problem: Minimum De-arrangements present in array of AP (Arithmetic Progression). */

  /** 243. Problem: Python | Sort a List according to the Length of the Elements. */

  /** 244. Problem: Alternate sorting of Linked list. */

  /** 245. Problem: Print n smallest elements from given array in their original order. */

  /** 246. Problem: De-arrangements for minimum product sum of two arrays. */

  /** 247. Problem: Sort the words in lexicographical order in Python. */

  /** 248. Problem: Maximum sum of pairwise product in an array with negative allowed. */

  /** 249. Problem: Rearrange array such that even positioned are greater than odd. */

  /** 250. Problem: Maximum triplet sum in array. */

  /** 251. Problem: Sum of Manhattan distances between all pairs of points. */

  /** 252. Problem: Python | Sort Tuples in Increasing Order by any key. */

  /** 253. Problem: Sorting array of strings (or words) using Trie | Set-2 (Handling Duplicates). */

  /** 254. Problem: Minimum number of subsets with distinct elements. */

  /** 255. Problem: k smallest elements in same order using O(1) extra space. */

  /** 256. Problem: Job Selection Problem &#8211; Loss Minimization Strategy | Set 2. */

  /** 257. Problem: Smallest subset with sum greater than all other elements. */

  /** 258. Problem: Minimum number of subtract operation to make an array decreasing. */

  /** 259. Problem: Alternate Lower Upper String Sort. */

  /** 260. Problem: Merge Sort using Multi-threading. */

  /** 261. Problem: QuickSort using Random Pivoting. */

  /** 262. Problem: Python | Sort a list according to the second element in sublist. */

  /** 263. Problem: Python | Sort words of sentence in ascending order. */

  /** 264. Problem: sort() in Python. */

  /** 265. Problem: Merge 3 Sorted Arrays. */

  /** 266. Problem: Sort an array of 0s, 1s and 2s (Simple Counting). */

  /** 267. Problem: Rank of all elements in an array. */

  /** 268. Problem: Insertion Sort by Swapping Elements. */

  /** 269. Problem: Closest numbers from a list of unsorted integers. */

  /** 270. Problem: Check if both halves of the string have at least one different character. */

  /** 271. Problem: Find k maximum elements of array in original order. */

  /** 272. Problem: Median and Mode using Counting Sort. */

  /** 273. Problem: Find number of pairs in an array such that their XOR is 0. */

  /** 274. Problem: Row wise sorting in 2D array. */

  /** 275. Problem: Lexicographical concatenation of all substrings of a string. */

  /** 276. Problem: Stable sort for descending order. */

  /** 277. Problem: Ropes  left after every removal of smallest. */

  /** 278. Problem: Sort an array using socket programming in C. */

  /** 279. Problem: Sort the given matrix. */

  /** 280. Problem: Sort the matrix row-wise and column-wise. */

  /** 281. Problem: Program for sorting variables of any data type. */

  /** 282. Problem: Insertion sort to sort even and odd positioned elements in different orders. */

  /** 283. Problem: Sort on the basis of number of factors using STL. */

  /** 284. Problem: Loop Invariant Condition with Examples of Sorting Algorithms. */

  /** 285. Problem: Pairs such that one is a power multiple of other. */

  /** 286. Problem: Sort the given string using character search. */

  /** 287. Problem: Find k-th smallest element in given n ranges. */

  /** 288. Problem: Iterative Heap Sort. */

  /** 289. Problem: Sorting rows of matrix in ascending order followed by columns in descending order. */

  /** 290. Problem: Maximum number of partitions that can be sorted individually to make sorted. */

  /** 291. Problem: Sort 1 to N by swapping adjacent elements. */

  /** 292. Problem: Most frequent element in an array. */

  /** 293. Problem: Least frequent element in an array. */

  /** 294. Problem: Shortest Un-ordered Subarray. */

  /** 295. Problem: Print number in ascending order which contains 1, 2 and 3 in their digits.. */

  /** 296. Problem: Heap Sort for decreasing order using min heap. */

  /** 297. Problem: Strand Sort. */

  /** 298. Problem: Sort the linked list in the order of elements appearing in the array. */

  /** 299. Problem: Sorting | Natural Language Programming. */

  /** 300. Problem: Sort an array containing two types of elements. */

  /** 301. Problem: Sorting all array elements except one. */

  /** 302. Problem: Minimum swaps required to Sort Binary array. */

  /** 303. Problem: Sorting a Queue without extra space. */

  /** 304. Problem: Pandigital Product. */

  /** 305. Problem: Sorting array except elements in a subarray. */

  /** 306. Problem: Smallest greater elements in whole array. */

  /** 307. Problem: PHP | Sort array of strings in natural and standard orders. */

  /** 308. Problem: Print sorted distinct elements of array in C++. */

  /** 309. Problem: Comparisons involved in Modified Quicksort Using Merge Sort Tree. */

  /** 310. Problem: Maximum possible difference of two subsets of an array. */

  /** 311. Problem: Check if linked list is sorted (Iterative and Recursive). */

  /** 312. Problem: Maximum sum of absolute difference of an array. */

  /** 313. Problem: Sort an array which contain 1 to n values. */





  /**
   * Bubble sort
   * Complexity: O(n^2)
   */
  void bubbleSort(int[] array) {
    for(int i = 0; i < array.length - 1; i++) {
      for(int j = 0; j < array.length - 1 - i; j++)
        if(array[j] > array[j + 1]) swap(array, j, j + 1);
    }
  }

  void recursiveBSort(int[] array, int length) {
    if (length == 1) return;
    for (int i = 0; i < length - 1; i++) if (array[i] > array[i + 1]) swap(array, i, i + 1);
    recursiveBSort(array, length - 1);
  }

  private void swap(int[] a, int i, int j) {
    if (i != j) {
      a[i] = a[i] ^ a[j];
      a[j] = a[i] ^ a[j];
      a[i] = a[i] ^ a[j];
    }
  }

  /**
   * Insertion sort
   * Complexity: O(n^2)
   */
  int[] insertionSort(int[] array) {
    for(int i = 1; i < array.length; i++) {
      int key = array[i];
      int j = i - 1;
      while (j >= 0 && array[j] > key) {
        array[j+1] = array[j];
        j--;
      }
      array[j+1] = key;
    }
    return array;
  }

  /**
   * Counting sort
   * It is an algorithm for sorting a collection of objects according to keys that are small integers;
   * that is, it is an integer sorting algorithm. It operates by counting the number of objects that have each
   * distinct key value, and using arithmetic on those counts to determine the positions of each key value in the
   * output sequence. Its running time is linear in the number of items and the difference between the maximum and
   * minimum key values, so it is only suitable for direct use in situations where the variation in keys is not
   * significantly greater than the number of items.
   * Because counting sort uses key values as indexes into an array, it is not a comparison sort, and the Ω(n log n)
   * lower bound for comparison sorting does not apply to it.
   * Time Complexity: O(n+k)
   */
  void countingSort(int[] array, int k) {
    int[] hash = new int[k+1];
    for(int elem : array) hash[elem]++;
    for (int i = 0; i < hash.length; i++)
      if (hash[i] > 0)
        for (int j = 0; j < hash[i]; j++)
          System.out.print(i + " ");
  }

  void countingSort2(int[] array, int k) {
    int[] hash = new int[k + 1];
    for (int elem : array) hash[elem]++;
    for (int i = 1; i < hash.length; i++) hash[i] += hash[i - 1];
    int[] output = new int[array.length];
    for (int elem : array) {
      output[hash[elem] - 1] = elem;
      hash[elem]--;
    }
    System.arraycopy(output, 0, array, 0, array.length);
  }

  /**
   * Selection sort
   * Step 1 − Set MIN to location 0
   * Step 2 − Search the minimum element in the list
   * Step 3 − Swap with value at location MIN
   * Step 4 − Increment MIN to point to next element
   * Step 5 − Repeat until list is sorted
   * Complexity: O(n^2)
   */
  void selectionSort(int[] array) {
    for (int i = 0; i < array.length - 1; i++) {
      int minIndex = i;
      for (int j = i + 1; j < array.length; j++)
        if (array[minIndex] > array[j]) minIndex = j;
      swap(array, i, minIndex);
    }
  }

  void recursiveSelectionSort(int[] array, int startIndex) {
    if (startIndex < array.length - 1) {
      swap(array, startIndex, getMinIndex(array, startIndex));
      recursiveSelectionSort(array, startIndex + 1);
    }
  }

  private int getMinIndex(int[] array, int startIndex) {
    int minIndex = startIndex;
    for (int j = startIndex + 1; j < array.length; j++)
      if (array[minIndex] > array[j]) minIndex = j;
    return minIndex;
  }

  /**
   * Pancake sorting.
   * Given an an unsorted array, sort the given array. You are allowed to do only following operation on array.
   * flip(arr, i): Reverse array from 0 to i
   * Unlike a traditional sorting algorithm, which attempts to sort with the fewest comparisons possible, the goal
   * is to sort the sequence in as few reversals as possible.
   * Solution: Start from current size equal to n and reduce current size by one while it’s greater than 1.
   * Let the current size be curr_size. Do following for every curr_size
   * 1) Find index of the maximum element in arr[0..curr_size-1]. Let the index be ‘mi’
   * b) Call flip(arr, mi)
   * c) Call flip(arr, curr_size-1)
   */
  void panCakeSort(int[] array, int endIndex) {
    if (endIndex > 0) {
      int maxIndex = getMaxIndex(array, endIndex);
      flip(array, 0, maxIndex);
      flip(array, 0, endIndex);
      panCakeSort(array, endIndex - 1);
    }
  }

  private int getMaxIndex(int[] array, int length) {
    int maxIndex = 0;
    for (int i = 1; i <= length; i++)
      if (array[maxIndex] < array[i]) maxIndex = i;
    return maxIndex;
  }

  private void flip(int[] array, int startIndex, int endIndex) {
    if (startIndex < endIndex) {
      swap(array, startIndex, endIndex);
      flip(array, startIndex + 1, endIndex - 1);
    }
  }

  /**
   * Merge sort
   * Complexity: O(nlog(n))
   */
  void mergeSort(int[] array, int start, int end) {
    if (start < end) {
      int mid = (start + end) / 2;
      mergeSort(array, start, mid);
      mergeSort(array,mid + 1, end);
      merge(array, start, mid, end);
    }
  }

  private void merge(int[] array, int start, int mid, int end) {
    int leftCount = mid - start + 1;
    int rightCount = end - mid;
    int[] leftArray = new int[leftCount + 1];
    int[] rightArray = new int[rightCount + 1];
    System.arraycopy(array, start, leftArray, 0, leftCount);
    System.arraycopy(array, mid + 1, rightArray, 0, rightCount);
    leftArray[leftCount] = Integer.MAX_VALUE;
    rightArray[rightCount] = Integer.MAX_VALUE;
    int leftPointer = 0;
    int rightPointer = 0;
    for (int i = start; i <= end; i++) {
      if (leftArray[leftPointer] <= rightArray[rightPointer]) {
        array[i] = leftArray[leftPointer];
        leftPointer++;
      } else {
        array[i] = rightArray[rightPointer];
        rightPointer++;
      }
    }
  }

  /**
   * Heap sort
   * Complexity: O(nlog(n))
   */
  void heapSort(int[] array) {
    int heapSize = array.length;
    buildMaxHeap(array, heapSize);
    for (int i = 0; i < array.length; i++) {
      extractMax(array, heapSize);
      heapSize--;
      heapify(array,0, heapSize);
    }
  }

  /**
   * An n-element heap has height floor(logn) and at most ceiling(n/(2^(h+1))) nodes of any height h.
   * So summation of no of nodes from 0 to height x O(h) reduces to linear time O(n).
   */
  private void buildMaxHeap(int[] array, int heapSize) {
    for (int i = heapSize/2 - 1; i >= 0 ; i--) heapify(array, i, heapSize);
  }

  private void heapify(int[] array, int i, int heapSize) {
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int max = i;
    if (left < heapSize && array[left] > array[max]) max = left;
    if (right < heapSize && array[right] > array[max]) max = right;
    if (array[i] < array[max]) {
      swap(array, i, max);
      heapify(array, max, heapSize);
    }
  }

  private void extractMax(int[] array, int heapSize) {
    swap(array, 0, heapSize - 1);
  }

  /**
   * Quick sort
   * Complexity: O(nlog(n))
   */
  void quickSort(int[] array, int start, int end) {
    if (start < end) {
      int pivot = partition(array, start, end);
      quickSort(array, start, pivot - 1);
      quickSort(array, pivot + 1, end);
    }
  }

  private int partition(int[] array, int start, int end) {
    int pivot = array[end];
    int soFar = start - 1;
    for (int j = start; j < end; j++) {
      if (array[j] <= pivot) {
        soFar++;
        swap(array, soFar, j);
      }
    }
    swap(array, soFar + 1, end);
    return soFar + 1;
  }

}
